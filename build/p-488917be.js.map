{"version":3,"names":["observed","Set","mutationObserver","observerOptions","childList","connectConditionalSlotComponent","component","createObserver","processMutations","observe","el","disconnectConditionalSlotComponent","delete","takeRecords","disconnect","element","entries","mutations","forEach","target","forceUpdate"],"sources":["./node_modules/@esri/calcite-components/dist/collection/utils/conditionalSlot.js"],"sourcesContent":["/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.\n * v1.2.0\n */\nimport { forceUpdate } from \"@stencil/core\";\nimport { createObserver } from \"./observers\";\nconst observed = new Set();\nlet mutationObserver;\nconst observerOptions = { childList: true };\n/**\n * Helper to set up a conditional slot component on connectedCallback.\n *\n * @param component\n * @deprecated Use `onSlotchange` event with `slotChangeHasAssignedElement` DOM utility instead.\n *\n * ```\n * <slot onSlotchange={(event) => this.mySlotHasElement = slotChangeHasAssignedElement(event)} />}\n * ```\n */\nexport function connectConditionalSlotComponent(component) {\n  if (!mutationObserver) {\n    mutationObserver = createObserver(\"mutation\", processMutations);\n  }\n  mutationObserver.observe(component.el, observerOptions);\n}\n/**\n * Helper to tear down a conditional slot component on disconnectedCallback.\n *\n * @param component\n * @deprecated Use `onSlotchange` event with `slotChangeHasAssignedElement` DOM utility instead.\n *\n * ```\n * <slot onSlotchange={(event) => this.mySlotHasElement = slotChangeHasAssignedElement(event)} />}\n * ```\n */\nexport function disconnectConditionalSlotComponent(component) {\n  observed.delete(component.el);\n  // we explicitly process queued mutations and disconnect and reconnect\n  // the observer until MutationObserver gets an `unobserve` method\n  // see https://github.com/whatwg/dom/issues/126\n  processMutations(mutationObserver.takeRecords());\n  mutationObserver.disconnect();\n  for (const [element] of observed.entries()) {\n    mutationObserver.observe(element, observerOptions);\n  }\n}\nfunction processMutations(mutations) {\n  mutations.forEach(({ target }) => {\n    forceUpdate(target);\n  });\n}\n"],"mappings":";;;;;GAOA,MAAMA,EAAW,IAAIC,IACrB,IAAIC,EACJ,MAAMC,EAAkB,CAAEC,UAAW,MAW9B,SAASC,EAAgCC,GAC9C,IAAKJ,EAAkB,CACrBA,EAAmBK,EAAe,WAAYC,EAClD,CACEN,EAAiBO,QAAQH,EAAUI,GAAIP,EACzC,CAWO,SAASQ,EAAmCL,GACjDN,EAASY,OAAON,EAAUI,IAI1BF,EAAiBN,EAAiBW,eAClCX,EAAiBY,aACjB,IAAK,MAAOC,KAAYf,EAASgB,UAAW,CAC1Cd,EAAiBO,QAAQM,EAASZ,EACtC,CACA,CACA,SAASK,EAAiBS,GACxBA,EAAUC,SAAQ,EAAGC,aACnBC,EAAYD,EAAO,GAEvB,Q"}