{"version":3,"names":["prototype","requestSubmit","submitter","validateSubmitter","this","click","document","createElement","type","hidden","appendChild","removeChild","form","HTMLElement","raise","TypeError","DOMException","errorConstructor","message","name","HTMLFormElement","hiddenFormInputSlotName","isCheckable","component","onFormResetMap","WeakMap","formComponentSet","WeakSet","hasRegisteredFormComponentParent","formComponentEl","hasParentComponentWithFormIdSet","closestElementCrossShadowBoundary","parentElement","formComponentRegisterEventName","addEventListener","event","composedPath","some","element","has","stopPropagation","once","dispatchEvent","CustomEvent","bubbles","composed","submitForm","formEl","resetForm","reset","connectForm","el","value","associatedForm","findAssociatedForm","defaultValue","defaultChecked","checked","boundOnFormReset","onFormReset","bind","set","add","queryElementRoots","id","disconnectForm","get","removeEventListener","delete","afterConnectDefaultValueSet","hiddenInputChangeHandler","target","removeHiddenInputChangeEventListener","input","syncHiddenFormInput","ownerDocument","inputs","querySelectorAll","forEach","remove","values","Array","isArray","extra","seen","Set","valueMatch","find","val","defaultSyncHiddenFormInput","push","docFrag","pop","slot","createDocumentFragment","append","disabled","required","tabIndex","setAttribute","removeAttribute","HiddenFormInputSlot","h"],"sources":["./node_modules/form-request-submit-polyfill/form-request-submit-polyfill.js","./node_modules/@esri/calcite-components/dist/collection/utils/form.js"],"sourcesContent":["(function(prototype) {\n  if (typeof prototype.requestSubmit == \"function\") return\n\n  prototype.requestSubmit = function(submitter) {\n    if (submitter) {\n      validateSubmitter(submitter, this)\n      submitter.click()\n    } else {\n      submitter = document.createElement(\"input\")\n      submitter.type = \"submit\"\n      submitter.hidden = true\n      this.appendChild(submitter)\n      submitter.click()\n      this.removeChild(submitter)\n    }\n  }\n\n  function validateSubmitter(submitter, form) {\n    submitter instanceof HTMLElement || raise(TypeError, \"parameter 1 is not of type 'HTMLElement'\")\n    submitter.type == \"submit\" || raise(TypeError, \"The specified element is not a submit button\")\n    submitter.form == form || raise(DOMException, \"The specified element is not owned by this form element\", \"NotFoundError\")\n  }\n\n  function raise(errorConstructor, message, name) {\n    throw new errorConstructor(\"Failed to execute 'requestSubmit' on 'HTMLFormElement': \" + message + \".\", name)\n  }\n})(HTMLFormElement.prototype);\n","/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.\n * v1.2.0\n */\nimport \"form-request-submit-polyfill/form-request-submit-polyfill\";\nimport { closestElementCrossShadowBoundary, queryElementRoots } from \"./dom\";\nimport { h } from \"@stencil/core\";\n/**\n * Exported for testing purposes.\n */\nexport const hiddenFormInputSlotName = \"hidden-form-input\";\nfunction isCheckable(component) {\n  return \"checked\" in component;\n}\nconst onFormResetMap = new WeakMap();\nconst formComponentSet = new WeakSet();\n/**\n * This helps determine if our form component is part of a composite form-associated component.\n *\n * @param form\n * @param formComponentEl\n */\nfunction hasRegisteredFormComponentParent(form, formComponentEl) {\n  // if we have a parent component using the form ID attribute, we assume it is form-associated\n  const hasParentComponentWithFormIdSet = closestElementCrossShadowBoundary(formComponentEl.parentElement, \"[form]\");\n  if (hasParentComponentWithFormIdSet) {\n    return true;\n  }\n  // we use events as a way to test for nested form-associated components across shadow bounds\n  const formComponentRegisterEventName = \"calciteInternalFormComponentRegister\";\n  let hasRegisteredFormComponentParent = false;\n  form.addEventListener(formComponentRegisterEventName, (event) => {\n    hasRegisteredFormComponentParent = event\n      .composedPath()\n      .some((element) => formComponentSet.has(element));\n    event.stopPropagation();\n  }, { once: true });\n  formComponentEl.dispatchEvent(new CustomEvent(formComponentRegisterEventName, {\n    bubbles: true,\n    composed: true\n  }));\n  return hasRegisteredFormComponentParent;\n}\n/**\n * Helper to submit a form.\n *\n * @param component\n * @returns true if its associated form was submitted, false otherwise.\n */\nexport function submitForm(component) {\n  const { formEl } = component;\n  if (!formEl) {\n    return false;\n  }\n  formEl.requestSubmit();\n  return true;\n}\n/**\n * Helper to reset a form.\n *\n * @param component\n */\nexport function resetForm(component) {\n  component.formEl?.reset();\n}\n/**\n * Helper to set up form interactions on connectedCallback.\n *\n * @param component\n */\nexport function connectForm(component) {\n  const { el, value } = component;\n  const associatedForm = findAssociatedForm(component);\n  if (!associatedForm || hasRegisteredFormComponentParent(associatedForm, el)) {\n    return;\n  }\n  component.formEl = associatedForm;\n  component.defaultValue = value;\n  if (isCheckable(component)) {\n    component.defaultChecked = component.checked;\n  }\n  const boundOnFormReset = (component.onFormReset || onFormReset).bind(component);\n  associatedForm.addEventListener(\"reset\", boundOnFormReset);\n  onFormResetMap.set(component.el, boundOnFormReset);\n  formComponentSet.add(el);\n}\n/**\n * Utility method to find a form-component's associated form element.\n *\n * @param component\n */\nexport function findAssociatedForm(component) {\n  const { el, form } = component;\n  return form\n    ? queryElementRoots(el, { id: form })\n    : closestElementCrossShadowBoundary(el, \"form\");\n}\nfunction onFormReset() {\n  if (isCheckable(this)) {\n    this.checked = this.defaultChecked;\n    return;\n  }\n  this.value = this.defaultValue;\n}\n/**\n * Helper to tear down form interactions on disconnectedCallback.\n *\n * @param component\n */\nexport function disconnectForm(component) {\n  const { el, formEl } = component;\n  if (!formEl) {\n    return;\n  }\n  const boundOnFormReset = onFormResetMap.get(el);\n  formEl.removeEventListener(\"reset\", boundOnFormReset);\n  onFormResetMap.delete(el);\n  component.formEl = null;\n  formComponentSet.delete(el);\n}\n/**\n * Helper for setting the default value on initialization after connectedCallback.\n *\n * Note that this is only needed if the default value cannot be determined on connectedCallback.\n *\n * @param component\n * @param value\n */\nexport function afterConnectDefaultValueSet(component, value) {\n  component.defaultValue = value;\n}\nconst hiddenInputChangeHandler = (event) => {\n  event.target.dispatchEvent(new CustomEvent(\"calciteInternalHiddenInputChange\", { bubbles: true }));\n};\nconst removeHiddenInputChangeEventListener = (input) => input.removeEventListener(\"change\", hiddenInputChangeHandler);\n/**\n * Helper for maintaining a form-associated's hidden input in sync with the component.\n *\n * Based on Ionic's approach: https://github.com/ionic-team/ionic-framework/blob/e4bf052794af9aac07f887013b9250d2a045eba3/core/src/utils/helpers.ts#L198\n *\n * @param component\n */\nfunction syncHiddenFormInput(component) {\n  const { el, formEl, name, value } = component;\n  const { ownerDocument } = el;\n  const inputs = el.querySelectorAll(`input[slot=\"${hiddenFormInputSlotName}\"]`);\n  if (!formEl || !name) {\n    inputs.forEach((input) => {\n      removeHiddenInputChangeEventListener(input);\n      input.remove();\n    });\n    return;\n  }\n  const values = Array.isArray(value) ? value : [value];\n  const extra = [];\n  const seen = new Set();\n  inputs.forEach((input) => {\n    const valueMatch = values.find((val) => \n    /* intentional non-strict equality check */\n    val == input.value);\n    if (valueMatch != null) {\n      seen.add(valueMatch);\n      defaultSyncHiddenFormInput(component, input, valueMatch);\n    }\n    else {\n      extra.push(input);\n    }\n  });\n  let docFrag;\n  values.forEach((value) => {\n    if (seen.has(value)) {\n      return;\n    }\n    let input = extra.pop();\n    if (!input) {\n      input = ownerDocument.createElement(\"input\");\n      input.slot = hiddenFormInputSlotName;\n    }\n    if (!docFrag) {\n      docFrag = ownerDocument.createDocumentFragment();\n    }\n    docFrag.append(input);\n    // emits when hidden input is autofilled\n    input.addEventListener(\"change\", hiddenInputChangeHandler);\n    defaultSyncHiddenFormInput(component, input, value);\n  });\n  if (docFrag) {\n    el.append(docFrag);\n  }\n  extra.forEach((input) => {\n    removeHiddenInputChangeEventListener(input);\n    input.remove();\n  });\n}\nfunction defaultSyncHiddenFormInput(component, input, value) {\n  const { defaultValue, disabled, form, name, required } = component;\n  // keep in sync to prevent losing reset value\n  input.defaultValue = defaultValue;\n  input.disabled = disabled;\n  input.name = name;\n  input.required = required;\n  input.tabIndex = -1;\n  // we set the attr as the prop is read-only\n  if (form) {\n    input.setAttribute(\"form\", form);\n  }\n  else {\n    input.removeAttribute(\"form\");\n  }\n  if (isCheckable(component)) {\n    input.checked = component.checked;\n    // keep in sync to prevent losing reset value\n    input.defaultChecked = component.defaultChecked;\n    // heuristic to support default/on mode from https://html.spec.whatwg.org/multipage/input.html#dom-input-value-default-on\n    input.value = component.checked ? value || \"on\" : \"\";\n  }\n  else {\n    input.value = value || \"\";\n  }\n  component.syncHiddenFormInput?.(input);\n}\n/**\n * Helper to render the slot for form-associated component's hidden input.\n *\n * If the component has a default slot, this must be placed at the bottom of the component's root container to ensure it is the last child.\n *\n * render(): VNode {\n *   <Host>\n *     <div class={CSS.container}>\n *     // ...\n *     <HiddenFormInputSlot component={this} />\n *     </div>\n *   </Host>\n * }\n *\n * Note that the hidden-form-input Sass mixin must be added to the component's style to apply specific styles.\n *\n * @param root0\n * @param root0.component\n */\nexport const HiddenFormInputSlot = ({ component }) => {\n  syncHiddenFormInput(component);\n  return h(\"slot\", { name: hiddenFormInputSlotName });\n};\n"],"mappings":"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"}