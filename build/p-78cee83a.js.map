{"version":3,"names":["inRange","date","min","max","time","getTime","afterMin","Date","beforeMax","dateFromRange","beforeMin","afterMax","dateFromISO","iso8601","isEndDate","d","split","map","parseFloat","setFullYear","isNaN","Error","setEndOfDay","dateFromLocalizedString","value","localeData","separator","day","month","year","parseDateString","validDay","validMonth","validDate","validLength","filter","c","length","validYear","toString","datePartsFromLocalizedString","string","unitOrder","order","getOrder","values","part","numberStringFormatter","delocalize","indexOf","dateToISO","getTimezoneOffset","toISOString","sameDate","d1","d2","getDate","getMonth","getFullYear","prevMonth","nextDate","setMonth","nextMonth","parseInt","signifiers","toLowerCase","sort","a","b","getDaysDiff","date1","date2","ts1","ts2","setHours"],"sources":["./node_modules/@esri/calcite-components/dist/collection/utils/date.js"],"sourcesContent":["/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.\n * v1.2.0\n */\nimport { numberStringFormatter } from \"./locale\";\n/**\n * Check if date is within a min and max\n *\n * @param date\n * @param min\n * @param max\n */\nexport function inRange(date, min, max) {\n  if (!date) {\n    return;\n  }\n  const time = date.getTime();\n  const afterMin = !(min instanceof Date) || time >= min.getTime();\n  const beforeMax = !(max instanceof Date) || time <= max.getTime();\n  return afterMin && beforeMax;\n}\n/**\n * Ensures date is within range,\n * returns min or max if out of bounds\n *\n * @param date\n * @param min\n * @param max\n */\nexport function dateFromRange(date, min, max) {\n  if (!(date instanceof Date)) {\n    return null;\n  }\n  const time = date.getTime();\n  const beforeMin = min instanceof Date && time < min.getTime();\n  const afterMax = max instanceof Date && time > max.getTime();\n  if (beforeMin) {\n    return min;\n  }\n  if (afterMax) {\n    return max;\n  }\n  return date;\n}\n/**\n * Parse an iso8601 string (YYYY-mm-dd) into a valid date.\n * TODO: handle time when time of day UI is added\n *\n * @param iso8601\n * @param isEndDate\n */\nexport function dateFromISO(iso8601, isEndDate = false) {\n  if (iso8601 instanceof Date) {\n    return iso8601;\n  }\n  if (!iso8601 || typeof iso8601 !== \"string\") {\n    return null;\n  }\n  const d = iso8601.split(/[: T-]/).map(parseFloat);\n  const date = new Date(d[0], (d[1] || 1) - 1, d[2] || 1);\n  date.setFullYear(d[0]);\n  if (isNaN(date.getTime())) {\n    throw new Error(`Invalid ISO 8601 date: \"${iso8601}\"`);\n  }\n  if (isEndDate) {\n    return setEndOfDay(date);\n  }\n  return date;\n}\n/**\n * Parse a localized date string into a valid Date.\n * return false if date is invalid, or out of range\n *\n * @param value\n * @param localeData\n */\nexport function dateFromLocalizedString(value, localeData) {\n  if (!localeData) {\n    return null;\n  }\n  const { separator } = localeData;\n  const { day, month, year } = parseDateString(value, localeData);\n  const date = new Date(year, month, day);\n  date.setFullYear(year);\n  const validDay = day > 0;\n  const validMonth = month > -1;\n  const validDate = !isNaN(date.getTime());\n  const validLength = value.split(separator).filter((c) => c).length > 2;\n  const validYear = year.toString().length > 0;\n  if (validDay && validMonth && validDate && validLength && validYear) {\n    return date;\n  }\n  return null;\n}\n/**\n * Retrieve day, month, and year strings from a localized string\n *\n * @param string\n * @param localeData\n */\nexport function datePartsFromLocalizedString(string, localeData) {\n  const { separator, unitOrder } = localeData;\n  const order = getOrder(unitOrder);\n  const values = string.split(separator).map((part) => numberStringFormatter.delocalize(part));\n  const day = values[order.indexOf(\"d\")];\n  const month = values[order.indexOf(\"m\")];\n  const year = values[order.indexOf(\"y\")];\n  return { day, month, year };\n}\n/**\n * Return first portion of ISO string (YYYY-mm-dd)\n *\n * @param date\n */\nexport function dateToISO(date) {\n  if (date instanceof Date) {\n    return new Date(date.getTime() - date.getTimezoneOffset() * 60000).toISOString().split(\"T\")[0];\n  }\n  return \"\";\n}\n/**\n * Check if two dates are the same day, month, year\n *\n * @param d1\n * @param d2\n */\nexport function sameDate(d1, d2) {\n  return (d1 instanceof Date &&\n    d2 instanceof Date &&\n    d1.getDate() === d2.getDate() &&\n    d1.getMonth() === d2.getMonth() &&\n    d1.getFullYear() === d2.getFullYear());\n}\n/**\n * Get a date one month in the past\n *\n * @param date\n */\nexport function prevMonth(date) {\n  const month = date.getMonth();\n  const nextDate = new Date(date);\n  nextDate.setMonth(month - 1);\n  // date doesn't exist in new month, use last day\n  if (month === nextDate.getMonth()) {\n    return new Date(date.getFullYear(), month, 0);\n  }\n  return nextDate;\n}\n/**\n * Get a date one month in the future\n *\n * @param date\n */\nexport function nextMonth(date) {\n  const month = date.getMonth();\n  const nextDate = new Date(date);\n  nextDate.setMonth(month + 1);\n  // date doesn't exist in new month, use last day\n  if ((month + 2) % 7 === nextDate.getMonth() % 7) {\n    return new Date(date.getFullYear(), month + 2, 0);\n  }\n  return nextDate;\n}\n/**\n * Parse numeric units for day, month, and year from a localized string\n * month starts at 0 (can pass to date constructor)\n * can return values as number or string\n *\n * @param string\n * @param localeData\n */\nexport function parseDateString(string, localeData) {\n  const { day, month, year } = datePartsFromLocalizedString(string, localeData);\n  return {\n    day: parseInt(day),\n    month: parseInt(month) - 1,\n    year: parseInt(year)\n  };\n}\n/**\n * Based on the unitOrder string, find order of month, day, and year for locale\n *\n * @param unitOrder\n */\nexport function getOrder(unitOrder) {\n  const signifiers = [\"d\", \"m\", \"y\"];\n  const order = unitOrder.toLowerCase();\n  return signifiers.sort((a, b) => order.indexOf(a) - order.indexOf(b));\n}\n/**\n * Get number of days between two dates\n *\n * @param date1\n * @param date2\n */\nexport function getDaysDiff(date1, date2) {\n  const ts1 = date1.getTime();\n  const ts2 = date2.getTime();\n  return (ts1 - ts2) / (1000 * 3600 * 24);\n}\n/**\n * Set time of the day to the end.\n *\n * @param {Date} date Date.\n * @returns {Date} Date with time set to end of day .\n */\nexport function setEndOfDay(date) {\n  date.setHours(23, 59, 59, 999);\n  return date;\n}\n"],"mappings":"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"}